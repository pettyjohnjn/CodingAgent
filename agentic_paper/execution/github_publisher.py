from __future__ import annotations

import base64
import fnmatch
import os
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Tuple

try:
    import requests  # type: ignore
except ImportError:  # pragma: no cover - optional dependency
    requests = None

# Basic ignore list so we do not push bulky or unneeded files
DEFAULT_IGNORE_PATTERNS = [
    ".git",
    ".git/*",
    "__pycache__",
    "__pycache__/*",
    "*.pyc",
    ".DS_Store",
    "env",
    "env/*",
]


def _slugify(text: str, max_len: int = 50) -> str:
    cleaned = "".join(ch if ch.isalnum() or ch in ("-", "_") else "-" for ch in text)
    while "--" in cleaned:
        cleaned = cleaned.replace("--", "-")
    cleaned = cleaned.strip("-_")
    if len(cleaned) > max_len:
        cleaned = cleaned[:max_len].rstrip("-_")
    return cleaned or "auto-repo"


def _get_token(token: Optional[str]) -> Optional[str]:
    return token or os.getenv("GITHUB_TOKEN") or os.getenv("GH_TOKEN")


def _headers(token: str) -> Dict[str, str]:
    return {
        "Authorization": f"Bearer {token}",
        "Accept": "application/vnd.github+json",
    }


def _should_ignore(rel_path: str, ignore_patterns: Iterable[str]) -> bool:
    parts = rel_path.split("/")
    for pat in ignore_patterns:
        if fnmatch.fnmatch(rel_path, pat):
            return True
        if any(fnmatch.fnmatch(part, pat) for part in parts):
            return True
    return False


def _iter_files(root_dir: str, ignore_patterns: Iterable[str]) -> Iterable[Tuple[Path, str]]:
    root = Path(root_dir).resolve()
    for path in root.rglob("*"):
        if not path.is_file():
            continue
        rel = str(path.relative_to(root)).replace(os.sep, "/")
        if _should_ignore(rel, ignore_patterns):
            continue
        yield path, rel


def create_repo(question: str, token: Optional[str] = None, visibility: str = "private") -> Dict[str, Any]:
    if requests is None:
        return {"created": False, "error": "requests is not installed in this environment"}
    token_val = _get_token(token)
    if not token_val:
        return {"created": False, "error": "Missing GITHUB_TOKEN or GH_TOKEN"}

    ts = datetime.utcnow().strftime("%Y%m%d-%H%M%S")
    slug = _slugify(question, max_len=40)
    repo_name = f"auto-paper-{slug}-{ts}"

    payload = {
        "name": repo_name,
        "description": "Auto-generated experiment code and paper artifacts.",
        "private": visibility != "public",
        "auto_init": True,
    }

    try:
        resp = requests.post(
            "https://api.github.com/user/repos",
            headers=_headers(token_val),
            json=payload,
            timeout=20,
        )
    except requests.RequestException as exc:
        return {"created": False, "error": str(exc)}

    if resp.status_code not in (200, 201):
        return {
            "created": False,
            "status": resp.status_code,
            "error": resp.text,
        }

    data = resp.json()
    return {
        "created": True,
        "repo": {
            "name": data.get("name"),
            "full_name": data.get("full_name"),
            "html_url": data.get("html_url"),
            "clone_url": data.get("clone_url"),
            "default_branch": data.get("default_branch", "main"),
        },
    }


def upload_run_artifacts(
    repo_full_name: str,
    source_dir: str,
    token: Optional[str] = None,
    branch: str = "main",
    commit_message: str = "Add autogenerated experiment artifacts",
    ignore_patterns: Optional[List[str]] = None,
) -> Dict[str, Any]:
    if requests is None:
        return {"uploaded": False, "error": "requests is not installed in this environment"}
    token_val = _get_token(token)
    if not token_val:
        return {"uploaded": False, "error": "Missing GITHUB_TOKEN or GH_TOKEN"}

    patterns = list(DEFAULT_IGNORE_PATTERNS)
    if ignore_patterns:
        patterns.extend(ignore_patterns)

    uploaded: List[str] = []
    errors: List[Dict[str, Any]] = []

    for path, rel in _iter_files(source_dir, patterns):
        try:
            content = path.read_bytes()
            b64 = base64.b64encode(content).decode("ascii")
            url = f"https://api.github.com/repos/{repo_full_name}/contents/{rel}"
            payload = {"message": commit_message, "content": b64, "branch": branch}
            resp = requests.put(url, headers=_headers(token_val), json=payload, timeout=20)
        except requests.RequestException as exc:
            errors.append({"file": rel, "error": str(exc)})
            continue
        except Exception as exc:
            errors.append({"file": rel, "error": str(exc)})
            continue

        if resp.status_code not in (200, 201):
            errors.append({"file": rel, "status": resp.status_code, "error": resp.text})
            continue

        uploaded.append(rel)

    return {
        "uploaded": len(errors) == 0 and len(uploaded) > 0,
        "uploaded_files": uploaded,
        "errors": errors,
        "branch": branch,
    }


def publish_run(
    question: str,
    run_root: str,
    token: Optional[str] = None,
    visibility: str = "private",
) -> Dict[str, Any]:
    """
    Create a GitHub repo for a completed run and upload artifacts.

    Returns a dict with keys:
      - created: bool
      - uploaded: bool
      - repo_url: str | None
      - repo_name: str | None
      - details/errors
    """
    create_resp = create_repo(question, token=token, visibility=visibility)
    if not create_resp.get("created"):
        return {
            "created": False,
            "uploaded": False,
            "error": create_resp.get("error"),
            "status": create_resp.get("status"),
        }

    repo = create_resp["repo"]
    repo_full_name = repo.get("full_name")
    repo_url = repo.get("html_url")
    branch = repo.get("default_branch", "main")

    upload_resp = upload_run_artifacts(
        repo_full_name=repo_full_name,
        source_dir=run_root,
        token=token,
        branch=branch,
    )

    result = {
        "created": True,
        "uploaded": upload_resp.get("uploaded", False),
        "repo_url": repo_url,
        "repo_name": repo_full_name,
        "branch": branch,
        "upload_errors": upload_resp.get("errors", []),
    }
    return result
